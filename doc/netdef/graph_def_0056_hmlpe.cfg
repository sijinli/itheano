# modified from 0055
# [ ] Add one more img transform layers fc_1_add
# [ ]
#------------------------------------------------
# Modified from 0054
#  [ ] doesn't learn conv1,conv2,conv3
#  [ ] doesn't init the weights for both prediction and embedding
#-----------------------------------------------
# Modified from 0042
# In this version, I will try 
# to seperate the image and pose transform layer
# and use pose estimation as outputs
# The network are forced to learn discriminative features via structure prediction
# --------------------------------------------
# Modified from 0041
# In this version, I will try to use very smaller number of nodes in the last layer
# So that try to reduce the overfitting problem
#---------------------------------------------
# Modified from 0037
# all the wd is set to 0.01
# Then the network will be trained so that the regularization term will not be 
# divided by n
# ---------------------------------------------
# Modified from 0034_corrected_version
# Here I 
# ---------------------------------------------
# It is strange the performance of current saved 0034 version is 
# worse than its "parent"" network
# I will save a check network and check its performance
# So all the learning rates here is zero
# Modified from 0023
#---------------------------------------------------
# Modified from 0022
# This version  I remove sqdiff cost from the network
# 
# Modified from 0021
# This version will init the weights 
#------------------------------------
# Combination  of 0012 and 0020
# 2015_02_02_acm_act_14_exp_2_19_graph_0012/
# FCJ0_act_14_graph_0020_test
#-------------------------------------


[imgdata]
type=data
inputs=s_imgdata
input_dims=(3, 112,112)
#channel, height, width

[joints]
type=data
inputs=s_joints
input_dims=51

[indmapjt]
type=data
inputs=s_indmapjt
input_dims=1700


[conv1]
type=conv
inputs=imgdata
sizeX=9
sizeY=9
filters=32
strideX=1
strideY=1
board_mode=valid
initW=0.00005
initb=0
wd=0
neuron=relu2
epsW=0.0005
epsB=0.002

# 32 @ 104 x 104

[pool1]
type=pool
inputs=conv1
sizeX=3
sizeY=3
strideX=2
strideY=2
pooling_type=max
# 32 @ 52 x 52

[conv2]
type=conv
inputs=pool1
sizeX=5
sizeY=5
filters=64
strideX=1
strideY=1
board_mode=valid
initW=0.001
initb=0
wd=0
neuron=relu2
epsW=0.0005
epsB=0.002

# 64 @ 48 x 48

[pool2]
type=pool
inputs=conv2
sizeX=3
sizeY=3
strideX=2
strideY=2
pooling_type=max
# 64 @ 24 x 24


[conv3]
type=conv
inputs=pool2
sizeX=5
sizeY=5
filters=64
strideX=1
strideY=1
board_mode=valid
initW=0.001
initb=0
wd=0
epsW=0.0005
epsB=0.002
#neuron=relu
# 64 @ 20 x 20

[pool3]
type=pool
inputs=conv3
sizeX=3
sizeY=3
strideX=2
strideY=2
pooling_type=max
# 64 @ 10 x 10


[fc_j0]
type=fc
inputs=pool3
output_dims=1024
wd=0.001
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=relu2



[fc_j0_dropout]	
type=dropout
inputs=fc_j0
keep=0.25

[fc_j1]
type=fc
inputs=fc_j0_dropout
output_dims=2048
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=relu2


[fc_j1_add]
type=fc
inputs=fc_j1
output_dims=1024
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=relu2


# This is for image feature representation
[fc_j2]
type=fc
inputs=fc_j1_add
output_dims=51
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=tanh[1,1]

[fc_ij0]
type=fc
inputs=pool3
output_dims=1024
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=relu2

[fc_ij0_dropout]
type=dropout
inputs=fc_ij0
keep=0.25

[fc_ij1]
type=fc
inputs=fc_ij0_dropout
output_dims=2048
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=relu2

[fc_ij2]
type=fc
inputs=fc_ij1
output_dims=1700
wd=0.01
initW=0.001
epsW=0.0005
epsB=0.002
initb=0
neuron=sigmoid

###################################
[sqdiffcost]
type=cost.sqdiff
inputs=joints,fc_j2
coeff=0.5

[indcost]
type=cost.bce
inputs=indmapjt,fc_ij2
coeff=0.5


[train_net]
type=network
data_layer_names=imgdata,joints,indmapjt
cost_layer_names=sqdiffcost,indcost
output_layer_names=
layer_with_weights=fc_j0,fc_j1,fc_j2,fc_j1_add

